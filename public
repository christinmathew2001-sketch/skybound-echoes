<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Skybound Echoes â€” Online</title>
<style>
  html,body{height:100%;margin:0;background:linear-gradient(#062 20%,#48b);}
  canvas{display:block;width:100%;height:100%}
  #ui{position:fixed;left:10px;top:10px;color:white;z-index:10}
  .panel{background:rgba(0,0,0,0.35);padding:10px;border-radius:8px;margin-bottom:8px;max-width:320px}
  input,button{padding:6px;border-radius:6px;border:none}
  button{background:white;color:#222}
</style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div><strong>Skybound Echoes</strong></div>
      <div style="margin-top:6px">Name: <input id="name" placeholder="pilot" /></div>
      <div style="margin-top:6px">
        <button id="join">Join (mic)</button>
        <button id="leave" disabled>Leave</button>
      </div>
      <div style="margin-top:6px">Players: <span id="players">0</span></div>
      <div style="margin-top:6px">Bubble radius: <span id="radiusVal">120</span></div>
      <div style="margin-top:6px"><small>Use WASD / arrow keys. Avoid ground. Collect coins.</small></div>
    </div>
  </div>

  <canvas id="c"></canvas>

<script>
(async function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let vw = innerWidth, vh = innerHeight;
  canvas.width = vw; canvas.height = vh;
  addEventListener('resize', ()=>{ vw=innerWidth; vh=innerHeight; canvas.width=vw; canvas.height=vh; });

  // UI
  const joinBtn = document.getElementById('join'), leaveBtn = document.getElementById('leave');
  const nameEl = document.getElementById('name'), playersEl = document.getElementById('players');
  const radiusValEl = document.getElementById('radiusVal');

  // connection
  const WS_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
  let ws, myId, world = { w:1600, h:900, groundY:780 };
  let localStream = null;
  let peers = {}; // id -> { pc, audioEl, gainNode, stream }
  let remoteAudioCtxs = {}; // audio context per remote

  // game local state
  const state = { x: 800 + Math.random()*40-20, y: 300 + Math.random()*40-20, bubbleRadius: 120, name: '' };
  let playersMap = {}; // id -> { id,name,x,y,bubbleRadius }
  let coins = [];

  // input
  const keys = {};
  addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // WebRTC helpers
  const ICE = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  async function startWS(){
    ws = new WebSocket(WS_URL);
    ws.onopen = ()=> console.log('ws open');
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'welcome') {
        myId = msg.id;
        world = msg.world || world;
        coins = msg.coins || coins;
        // send join info
        send({ type: 'join', name: state.name, x: state.x, y: state.y });
      }
      if (msg.type === 'state') {
        // update players and coins (server-authoritative)
        playersMap = {};
        (msg.players||[]).forEach(p => { playersMap[p.id] = p; });
        coins = (msg.coins||[]).map(c => c);
        playersEl.textContent = Object.keys(playersMap).length;
      }
      if (msg.type === 'signal') {
        handleSignal(msg.from, msg.data);
      }
    };
    ws.onclose = ()=> console.log('ws closed');
  }

  function send(obj){
    if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
  }

  // WebRTC signalling flow (simple mesh): when server forwards a signal, we act accordingly.
  async function createPeer(targetId, isInitiator = true){
    if (peers[targetId]) return peers[targetId].pc;
    const pc = new RTCPeerConnection(ICE);
    // attach local audio
    if (localStream) for(const t of localStream.getTracks()) pc.addTrack(t, localStream);

    // create audio element + webaudio gain
    const audioEl = document.createElement('audio'); audioEl.autoplay = true; audioEl.controls = false; audioEl.style.display='none';
    document.body.appendChild(audioEl);

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = audioCtx.createGain(); gainNode.gain.value = 0;
    // We'll connect when track arrives (createMediaElementSource once audioEl.srcObject is set)
    pc.ontrack = (e) => {
      audioEl.srcObject = e.streams[0];
      // connect after a short timeout to ensure autoplay/playback readiness
      setTimeout(()=>{
        try {
          const src = audioCtx.createMediaElementSource(audioEl);
          src.connect(gainNode).connect(audioCtx.destination);
        } catch(e) {
          // some browsers restrict connecting multiple times; ignore
        }
      }, 50);
    };

    pc.onicecandidate = e => {
      if (e.candidate) send({ type: 'signal', to: targetId, data: { type: 'ice', candidate: e.candidate } });
    };

    peers[targetId] = { pc, audioEl, gainNode };
    if (isInitiator) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      send({ type: 'signal', to: targetId, data: { type: 'sdp', sdp: pc.localDescription }});
    }
    return pc;
  }

  async function handleSignal(from, data){
    if (!peers[from] && data.type === 'sdp' && data.sdp && data.sdp.type === 'offer') {
      // create peer (non-initiator)
      await createPeer(from, false);
    }
    const entry = peers[from];
    if (!entry) return;
    const pc = entry.pc;
    if (data.type === 'sdp') {
      await pc.setRemoteDescription(data.sdp);
      if (data.sdp.type === 'offer') {
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        send({ type: 'signal', to: from, data: { type: 'sdp', sdp: pc.localDescription }});
      }
    } else if (data.type === 'ice') {
      try { await pc.addIceCandidate(data.candidate); } catch(e) {}
    }
  }

  // periodically ensure we have connections to other players reported by server
  setInterval(() => {
    for (const id of Object.keys(playersMap)) {
      if (id === myId) continue;
      if (!peers[id]) createPeer(id, true).catch(()=>{});
    }
    // cleanup peers who left
    for (const id of Object.keys(peers)) {
      if (!playersMap[id]) {
        try { peers[id].pc.close(); } catch(e) {}
        peers[id].audioEl.remove();
        delete peers[id];
      }
    }
  }, 1000);

  // audio distance update
  function updateAudioGains(){
    for (const id in peers) {
      const p = playersMap[id];
      if (!p || !peers[id]) continue;
      const dx = p.x - state.x, dy = p.y - state.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      const r = state.bubbleRadius || 120;
      let g = 0;
      if (d <= r) g = 1;
      else if (d <= r*2) g = 1 - (d - r) / r;
      else g = 0;
      try { peers[id].gainNode.gain.value = g; } catch(e) {}
    }
  }

  // UI join/leave
  joinBtn.onclick = async () => {
    const name = (nameEl.value || 'Pilot').slice(0,32);
    state.name = name;
    joinBtn.disabled = true;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch(e) {
      alert('Mic permission required for voice.'); joinBtn.disabled = false; return;
    }
    await startWS();
    send({ type: 'join', name: state.name, x: state.x, y: state.y });
    leaveBtn.disabled = false;
  };
  leaveBtn.onclick = () => {
    if (ws) ws.close();
    ws = null;
    for (const id in peers) {
      try { peers[id].pc.close(); } catch(e) {}
      try { peers[id].audioEl.remove(); } catch(e) {}
    }
    peers = {};
    joinBtn.disabled = false;
    leaveBtn.disabled = true;
  };

  // gameplay: movement and sending position
  function step(dt){
    const speed = 2.2;
    let dx=0, dy=0;
    if (keys['w']||keys['arrowup']) dy -= speed;
    if (keys['s']||keys['arrowdown']) dy += speed;
    if (keys['a']||keys['arrowleft']) dx -= speed;
    if (keys['d']||keys['arrowright']) dx += speed;
    state.x = Math.max(0, Math.min(world.w, state.x + dx));
    state.y = Math.max(0, Math.min(world.h, state.y + dy));

    // if hit ground, respawn
    if (state.y > world.groundY) {
      state.x = world.w/2 + (Math.random()*200-100);
      state.y = world.h/2 - 200;
      // ask server to re-spawn coins (simple approach: reload page or rely on server's coin timetable)
      // We'll just keep going; server could respawn later.
    }

    // send position update to server
    if (ws && ws.readyState === WebSocket.OPEN) {
      send({ type: 'update', x: state.x, y: state.y, bubbleRadius: state.bubbleRadius });
    }

    // check local coin collision and request collect
    for (const c of coins) {
      if (c.taken) continue;
      const dx2 = c.x - state.x, dy2 = c.y - state.y;
      if (dx2*dx2 + dy2*dy2 < 18*18) {
        // ask server to collect
        send({ type: 'collect', coinId: c.id });
      }
    }

    // audio fade updates
    updateAudioGains();
  }

  // draw
  function draw(){
    const camX = state.x - vw/2, camY = state.y - vh/2;
    // sky
    const g = ctx.createLinearGradient(0,0,0,vh);
    g.addColorStop(0,'#052'); g.addColorStop(1,'#79b');
    ctx.fillStyle = g; ctx.fillRect(0,0,vw,vh);

    // clouds
    for (let i=0;i<15;i++){
      const cx = ((i*97) % world.w) - camX;
      const cy = 60 + ((i*53)%200) - camY*0.02;
      ctx.globalAlpha = 0.12; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy,100,36,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }

    // coins
    for (const c of coins) {
      if (c.taken) continue;
      const sx = c.x - camX, sy = c.y - camY;
      ctx.fillStyle='gold'; ctx.beginPath(); ctx.arc(sx,sy,9,0,Math.PI*2); ctx.fill();
    }

    // ground
    const gy = world.groundY - camY;
    ctx.fillStyle='#2b5'; ctx.fillRect(0,gy,vw,vh-gy);

    // other players
    for (const id in playersMap) {
      if (id === myId) continue;
      const p = playersMap[id];
      const sx = p.x - camX, sy = p.y - camY;
      ctx.beginPath(); ctx.fillStyle='#ffd'; ctx.arc(sx,sy,10,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='white'; ctx.fillText(p.name || id, sx+12, sy+4);
    }

    // local player in center
    const lx = vw/2, ly = vh/2;
    ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2; ctx.arc(lx,ly,state.bubbleRadius,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(lx,ly,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillText(state.name || 'You', lx+16, ly-6);
  }

  // loop
  let last = performance.now();
  function loop(t){
    const dt = (t-last)/1000; last = t;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // bubble radius adjust keys
  addEventListener('keydown', e => {
    if (e.key === '+' || e.key === '=') { state.bubbleRadius += 10; radiusValEl.textContent = state.bubbleRadius; }
    if (e.key === '-' || e.key === '_') { state.bubbleRadius = Math.max(40, state.bubbleRadius - 10); radiusValEl.textContent = state.bubbleRadius; }
    if (e.key === 'm') {
      if (localStream) {
        for (const t of localStream.getAudioTracks()) t.enabled = !t.enabled;
      }
    }
  });

})();
</script>
</body>
</html>
